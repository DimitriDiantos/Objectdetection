# -*- coding: utf-8 -*-
"""Project_of_Aircraft_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PJk8nnKIVm6JehJJm5c_7jr_pUHYEAwY

# SYSTEM CHECK
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import numpy as np
import pandas as pd
import ast
import torch
import PIL
from tqdm.auto import tqdm
import shutil as sh
from pathlib import Path
import random

from IPython.display import Image, clear_output
import matplotlib.pyplot as plt
# %matplotlib inline
import PIL.Image
import tensorflow as tf
import tensorflow_datasets as tfds

gpus = tf.config.list_physical_devices('GPU')
cpus = tf.config.list_physical_devices('CPU')
print(gpus)
print(cpus)

"""Choose your device for computation. CPU or one of your CUDA devices."""

tf.config.set_visible_devices(gpus, 'GPU')

"""Import of files from my google drive"""

from google.colab import drive
drive.mount('/content/gdrive/')

!mkdir OpenImages

!mkdir /content/gdrive/MyDrive/OpenImages

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/MyDrive/OpenImages

!pwd

"""# Import of annotation from OpenImages website

"""

# Download required meta-files
!wget https://storage.googleapis.com/openimages/2018_04/class-descriptions-boxable.csv

!wget https://storage.googleapis.com/openimages/2018_04/train/train-annotations-bbox.csv

!wget https://storage.googleapis.com/openimages/2018_04/validation/validation-annotations-bbox.csv

!wget https://storage.googleapis.com/openimages/2018_04/test/test-annotations-bbox.csv

!pip install awscli

# Commented out IPython magic to ensure Python compatibility.
# #This magic function is used to create the files.downloadOI.py is the file name
# %%writefile downloadOI.py
# 
# #### Usage example: python3 downloadOI.py --classes 'Aircraft,Airplane' --mode train
# 
# import argparse
# import csv
# import subprocess
# import os
# from tqdm import tqdm
# import multiprocessing
# from multiprocessing import Pool as thread_pool
# 
# cpu_count = multiprocessing.cpu_count()
# 
# parser = argparse.ArgumentParser(description='Download Class specific images from OpenImagesV4')
# parser.add_argument("--mode", help="Dataset category - train, validation or test", required=True)
# parser.add_argument("--classes", help="Names of object classes to be downloaded", required=True)
# parser.add_argument("--nthreads", help="Number of threads to use", required=False, type=int, default=cpu_count*2)
# parser.add_argument("--occluded", help="Include occluded images", required=False, type=int, default=1)
# parser.add_argument("--truncated", help="Include truncated images", required=False, type=int, default=1)
# parser.add_argument("--groupOf", help="Include groupOf images", required=False, type=int, default=1)
# parser.add_argument("--depiction", help="Include depiction images", required=False, type=int, default=1)
# parser.add_argument("--inside", help="Include inside images", required=False, type=int, default=1)
# 
# args = parser.parse_args()
# 
# run_mode = args.mode
# 
# threads = args.nthreads
# 
# classes = []
# for class_name in args.classes.split(','):
#     classes.append(class_name)
# 
# with open('./class-descriptions-boxable.csv', mode='r') as infile:
#     reader = csv.reader(infile)
#     dict_list = {rows[1]:rows[0] for rows in reader}
# 
# subprocess.run(['rm', '-rf', run_mode])
# subprocess.run([ 'mkdir', run_mode])
# 
# pool = thread_pool(threads)
# commands = []
# cnt = 0
# 
# for ind in range(0, len(classes)):
# 
#     class_name = classes[ind]
#     print("Class "+str(ind) + " : " + class_name)
# 
#     subprocess.run([ 'mkdir', run_mode+'/'+class_name])
# 
#     command = "grep "+dict_list[class_name.replace('_', ' ')] + " ./" + run_mode + "-annotations-bbox.csv"
#     class_annotations = subprocess.run(command.split(), stdout=subprocess.PIPE).stdout.decode('utf-8')
#     class_annotations = class_annotations.splitlines()
# 
#     for line in class_annotations:
# 
#         line_parts = line.split(',')
# 
#         #IsOccluded,IsTruncated,IsGroupOf,IsDepiction,IsInside
#         if (args.occluded==0 and int(line_parts[8])>0):
#             print("Skipped %s",line_parts[0])
#             continue
#         if (args.truncated==0 and int(line_parts[9])>0):
#             print("Skipped %s",line_parts[0])
#             continue
#         if (args.groupOf==0 and int(line_parts[10])>0):
#             print("Skipped %s",line_parts[0])
#             continue
#         if (args.depiction==0 and int(line_parts[11])>0):
#             print("Skipped %s",line_parts[0])
#             continue
#         if (args.inside==0 and int(line_parts[12])>0):
#             print("Skipped %s",line_parts[0])
#             continue
# 
#         cnt = cnt + 1
# 
#         command = 'aws s3 --no-sign-request --only-show-errors cp s3://open-images-dataset/'+run_mode+'/'+line_parts[0]+'.jpg '+ run_mode+'/'+class_name+'/'+line_parts[0]+'.jpg'
#         commands.append(command)
# 
#         with open('%s/%s/%s.txt'%(run_mode,class_name,line_parts[0]),'a') as f:
#             f.write(','.join([class_name, line_parts[4], line_parts[5], line_parts[6], line_parts[7]])+'\n')
# 
# print("Annotation Count : "+str(cnt))
# commands = list(set(commands))
# print("Number of images to be downloaded : "+str(len(commands)))
# 
# list(tqdm(pool.imap(os.system, commands), total = len(commands) ))
# 
# pool.close()
# pool.join()

"""#Download of image of Aircraft and Airplane from Open images."""

# Download Sink and Toilet images for test
!python3 downloadOI.py --classes "Aircraft,Airplane" --mode test
# Download Sink and Toilet images for train
!python3 downloadOI.py --classes "Aircraft,Airplane" --mode train
# Download Sink and Toilet images for validation
!python3 downloadOI.py --classes "Aircraft,Airplane" --mode validation

!ls /content/gdrive/MyDrive/OpenImages

!pip install ultralytics

from IPython import display
display.clear_output()
!yolo checks

DATA_DIR = Path('/content/gdrive/MyDrive/OpenImages/final-airplane--1/')
images_dir = DATA_DIR / 'train/images'

if not DATA_DIR.exists():
    print(f"ERROR: {DATA_DIR} does not exist.")
elif not images_dir.exists():
    print(f"ERROR: {images_dir} does not exist.")
else:
    img_list = list(images_dir.glob('*.jpg'))
    if len(img_list) == 0:
        print("ERROR: No image files found in the 'images' directory.")
    else:
        pickone = random.choice(img_list)
        display.Image(pickone)

DATA_DIR = Path('/content/gdrive/MyDrive/OpenImages/final-airplane--1/')
img_list = list(DATA_DIR.glob('train/images/*.jpg'))
pickone = random.choice(img_list)
display.Image(pickone)

print(f"Found {len(img_list)} images files in {DATA_DIR}")

img = PIL.Image.open(pickone)
IMAGE_HEIGHT, IMAGE_WIDTH = img.size
num_channels = len(img.mode)
print("Image size: {}".format((IMAGE_HEIGHT, IMAGE_WIDTH)))
print("Num channels: {}".format(num_channels))

DATA_DIR1 = Path('/content/gdrive/MyDrive/OpenImages')
df = pd.read_csv(DATA_DIR1 / 'train-annotations-bbox.csv')
# convert a string record into a valid python object
def f(x):
    return ast.literal_eval(x.rstrip('\r\n'))

df = pd.read_csv(DATA_DIR1 / "train-annotations-bbox.csv",
                converters={'geometry': f})
df.head(10)

DATA_DIR2 = Path('/content/gdrive/MyDrive/OpenImages')
df = pd.read_csv(DATA_DIR2 / 'validation-annotations-bbox.csv')
# convert a string record into a valid python object
def f(x):
    return ast.literal_eval(x.rstrip('\r\n'))

df = pd.read_csv(DATA_DIR2 / "validation-annotations-bbox.csv",
                converters={'geometry': f})
df.head(10)

DATA_DIR3 = Path('/content/gdrive/MyDrive/OpenImages')
df = pd.read_csv(DATA_DIR3 / 'test-annotations-bbox.csv')
# convert a string record into a valid python object
def f(x):
    return ast.literal_eval(x.rstrip('\r\n'))

df = pd.read_csv(DATA_DIR3 / "test-annotations-bbox.csv",
                converters={'geometry': f})
df.head(10)

"""#Training"""

HOME = "/content/gdrive/MyDrive/OpenImages/final-airplane--1/"
!yolo task=detect mode=train model=yolov8s.pt data={HOME}/data.yaml epochs=500 imgsz=416

"""# Validation"""

!yolo task=detect mode=val model=/content/gdrive/MyDrive/OpenImages/runs/detect/train2/weights/best.pt data=/content/gdrive/MyDrive/OpenImages/final-airplane--1/data.yaml

!ls /content/gdrive/MyDrive/OpenImages/final-airplane--1/runs/detect/train

"""Listing of all the training and validtion elements(F1-score, Confusion matrix...)"""

!ls /content/gdrive/MyDrive/MasterProject/runs/detect/train/

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/train/confusion_matrix.png', width=1000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/val2/confusion_matrix_normalized.png', width=1000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/train2/results.png', width=2000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/val2/val_batch2_labels.jpg', width=1000)

display.Image(filename=f'//content/gdrive/MyDrive/OpenImages/runs/detect/train/F1_curve.png', width=1000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/val/PR_curve.png', width=1000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/val/F1_curve.png', width=1000)

display.Image(filename=f'{HOME}/runs/detect/train/labels.jpg', width=2000)

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/train/confusion_matrix_normalized.png', width=1000)

display.Image(filename=f'{HOME}/runs/detect/train/F1_curve.png', width=1000)

import plotly.express as px
import pandas as pd

df = pd.read_csv("/content/gdrive/MyDrive/OpenImages/runs/detect/train2/results.csv")
fig = px.line(df, x='                  epoch', y='       metrics/mAP50(B)', title='mAP50')
fig.show()

df

display.Image(filename=f'/content/gdrive/MyDrive/OpenImages/runs/detect/val/F1_curve.png', width=1000)

display.Image(filename=f'{HOME}/runs/detect/val2/P_curve.png', width=1000)

display.Image(filename=f'{HOME}/runs/detect/val2/R_curve.png', width=1000)

!yolo task=detect mode=val model=/content/gdrive/MyDrive/OpenImages/runs/detect/train/weights/best.pt data=/content/gdrive/MyDrive/OpenImages/final-airplane--1/data.yaml

"""#Prediction"""

!yolo task=detect mode=predict model=/content/gdrive/MyDrive/OpenImages/runs/detect/train/weights/best.pt source='/content/gdrive/MyDrive/OpenImages/input/airplane.jpg' show=True

"""#Show only a predicted bild"""

import subprocess
import matplotlib.pyplot as plt
from PIL import Image
import re

# Define the command to execute
command = "yolo task=detect mode=predict model=/content/gdrive/MyDrive/MasterProject/runs/detect/train/weights/yolov8n.pt source='/content/gdrive/MyDrive/MasterProject/input/'"

# Execute the command and capture the output
output = subprocess.getoutput(command)

# Specify the base directory
base_directory = "/content/gdrive/MyDrive/MasterProject/runs/detect"

# Find the latest "predict" directory
predict_directory = None
predict_number = -1

for folder_name in os.listdir(base_directory):
    if folder_name.startswith("predict"):
        match = re.search(r"\d+$", folder_name)
        if match:
            current_number = int(match.group())
            if current_number > predict_number:
                predict_number = current_number
                predict_directory = folder_name

# Check if a "predict" directory was found
if predict_directory:
    # Construct the path to the resulting image
    result_image_path = os.path.join(base_directory, predict_directory, "airplane.jpg")
    result_image_path1 = os.path.join(base_directory, predict_directory, "emirates-airplane.jpg")
    # Check if the resulting image exists
    if os.path.isfile(result_image_path):
        # Load and display the resulting image
        result_image = Image.open(result_image_path)
        plt.imshow(result_image)
        plt.axis('off')
        plt.show()

     # Check if the resulting image exists
    if os.path.isfile(result_image_path1):
        # Load and display the resulting image
        result_image = Image.open(result_image_path1)
        plt.imshow(result_image)
        plt.axis('off')
        plt.show()
    else:
        print("Resulting image not found.")
else:
    print("No 'predict' directory found.")

"""#Show only the predicted video"""

import subprocess
import matplotlib.pyplot as plt
from PIL import Image
import re
from IPython.display import HTML
import imageio
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from skimage.transform import resize
import imageio.core.util

def display_video(video):
    # Display size specification
    fig = plt.figure(figsize=(10, 10))

    mov = []
    # Append video one by one to mov
    for i in range(len(video)):
        img = plt.imshow(video[i], animated=True)
        plt.axis('off')
        mov.append([img])

    # Animation creation
    anime = animation.ArtistAnimation(fig, mov, interval=50, repeat_delay=1000)
    plt.close()
    return anime

def play_predicted_video(video):
    display(HTML(display_video(video).to_html5_video()))

# Define the command to execute
command = "yolo task=detect mode=predict model=/content/gdrive/MyDrive/OpenImages/runs/detect/train/weights/best.pt source='/content/gdrive/MyDrive/MasterProject/input/airplane.mp4'"

# Execute the command and capture the output
output = subprocess.getoutput(command)

# Specify the base directory
base_directory = "/content/gdrive/MyDrive/MasterProject/runs/detect"

# Find the latest "predict" directory
predict_directory = None
predict_number = -1

for folder_name in os.listdir(base_directory):
    match = re.match(r"predict(\d+)", folder_name)
    if match:
        current_number = int(match.group(1))
        if current_number > predict_number:
            predict_number = current_number
            predict_directory = folder_name

# Check if a "predict" directory was found
if predict_directory:
    imageio.core.util._max_read_total_bytes = 500000000  # Increase threshold to 500,000,000 bytes
    video_path = os.path.join(base_directory, predict_directory, "airplane.avi")
    video_reader = imageio.get_reader(video_path)
    video = [resize(frame, (800, 800)) for frame in video_reader]
    play_predicted_video(video)
else:
    print("No 'predict' directory found.")

"""#Prediction of user's bild or video"""

import os
import re
import subprocess
from google.colab import files
from IPython.display import HTML, display as ipy_display

import imageio
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from skimage.transform import resize

# Function to display the video
def display_video(video):
    # Display size specification
    fig = plt.figure(figsize=(10, 10))

    mov = []
    # Append video one by one to mov
    for i in range(len(video)):
        img = plt.imshow(video[i], animated=True)
        plt.axis('off')
        mov.append([img])

    # Animation creation
    anime = animation.ArtistAnimation(fig, mov, interval=50, repeat_delay=1000)
    plt.close()
    return anime

# Function to play the predicted video
def play_predicted_video(video_path):
    video_reader = imageio.get_reader(video_path)
    video = [resize(frame, (800, 800)) for frame in video_reader]
    ipy_display(HTML(display_video(video).to_html5_video()))

# Function to handle file upload
def handle_upload(upload):
    # Save the uploaded file locally with a default name
    file_path = "/content/gdrive/MyDrive/MasterProject/input.mp4"  # Modify the path and filename as needed
    with open(file_path, 'wb') as f:
        f.write(upload)

    # Call the prediction function with the file path
    predict(file_path)

# Function for prediction
def predict(file_path):
    # Define the command to execute
    command = f"yolo task=detect mode=predict model=/content/gdrive/MyDrive/OpenImages/runs/detect/train2/weights/best.pt source='{file_path}'"

    # Execute the command and capture the output
    output = subprocess.getoutput(command)

    # Specify the base directory
    base_directory = "/content/gdrive/MyDrive/OpenImages/runs/detect"

    # Find the latest "predict" directory
    predict_directory = None
    predict_number = -1

    for folder_name in os.listdir(base_directory):
        match = re.match(r"predict(\d+)", folder_name)
        if match:
            current_number = int(match.group(1))
            if current_number > predict_number:
                predict_number = current_number
                predict_directory = folder_name

    # Check if a "predict" directory was found
    if predict_directory:
        video_path = os.path.join(base_directory, predict_directory, "input.avi")
        if os.path.isfile(video_path):
            play_predicted_video(video_path)
        else:
            print("Predicted video not found.")
    else:
        print("No 'predict' directory found.")

# Ask the user to upload a file
uploaded_files = files.upload()

# Handle the uploaded files
for filename, content in uploaded_files.items():
    handle_upload(content)



